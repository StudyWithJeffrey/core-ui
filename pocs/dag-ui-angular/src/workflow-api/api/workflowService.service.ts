/**
 * workflow.proto
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: version not set
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 *//* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent }                           from '@angular/common/http';
import { CustomHttpUrlEncodingCodec }                        from '../encoder';

import { Observable }                                        from 'rxjs';

import { ApiArchiveWorkflowTemplateResponse } from '../model/apiArchiveWorkflowTemplateResponse';
import { ApiGetWorkflowMetricsResponse } from '../model/apiGetWorkflowMetricsResponse';
import { ApiListWorkflowTemplateVersionsResponse } from '../model/apiListWorkflowTemplateVersionsResponse';
import { ApiListWorkflowTemplatesResponse } from '../model/apiListWorkflowTemplatesResponse';
import { ApiListWorkflowsResponse } from '../model/apiListWorkflowsResponse';
import { ApiWorkflow } from '../model/apiWorkflow';
import { ApiWorkflowTemplate } from '../model/apiWorkflowTemplate';
import { XStreamDefinitionsapiLogEntry } from '../model/xStreamDefinitionsapiLogEntry';
import { XStreamDefinitionsapiWorkflow } from '../model/xStreamDefinitionsapiWorkflow';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';


@Injectable()
export class WorkflowServiceService {

    protected basePath = '/';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }


    /**
     * 
     * 
     * @param namespace 
     * @param uid 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public archiveWorkflowTemplate(namespace: string, uid: string, observe?: 'body', reportProgress?: boolean): Observable<ApiArchiveWorkflowTemplateResponse>;
    public archiveWorkflowTemplate(namespace: string, uid: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ApiArchiveWorkflowTemplateResponse>>;
    public archiveWorkflowTemplate(namespace: string, uid: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ApiArchiveWorkflowTemplateResponse>>;
    public archiveWorkflowTemplate(namespace: string, uid: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling archiveWorkflowTemplate.');
        }

        if (uid === null || uid === undefined) {
            throw new Error('Required parameter uid was null or undefined when calling archiveWorkflowTemplate.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<ApiArchiveWorkflowTemplateResponse>('put',`${this.basePath}/apis/v1beta1/${encodeURIComponent(String(namespace))}/workflow_templates/${encodeURIComponent(String(uid))}/archive`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Creates a Workflow
     * 
     * @param body 
     * @param namespace 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public createWorkflow(body: ApiWorkflow, namespace: string, observe?: 'body', reportProgress?: boolean): Observable<ApiWorkflow>;
    public createWorkflow(body: ApiWorkflow, namespace: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ApiWorkflow>>;
    public createWorkflow(body: ApiWorkflow, namespace: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ApiWorkflow>>;
    public createWorkflow(body: ApiWorkflow, namespace: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createWorkflow.');
        }

        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling createWorkflow.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<ApiWorkflow>('post',`${this.basePath}/apis/v1beta1/${encodeURIComponent(String(namespace))}/workflows`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param body 
     * @param namespace 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public createWorkflowTemplate(body: ApiWorkflowTemplate, namespace: string, observe?: 'body', reportProgress?: boolean): Observable<ApiWorkflowTemplate>;
    public createWorkflowTemplate(body: ApiWorkflowTemplate, namespace: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ApiWorkflowTemplate>>;
    public createWorkflowTemplate(body: ApiWorkflowTemplate, namespace: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ApiWorkflowTemplate>>;
    public createWorkflowTemplate(body: ApiWorkflowTemplate, namespace: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createWorkflowTemplate.');
        }

        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling createWorkflowTemplate.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<ApiWorkflowTemplate>('post',`${this.basePath}/apis/v1beta1/${encodeURIComponent(String(namespace))}/workflow_templates`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param body 
     * @param namespace 
     * @param workflowTemplateUid 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public createWorkflowTemplateVersion(body: ApiWorkflowTemplate, namespace: string, workflowTemplateUid: string, observe?: 'body', reportProgress?: boolean): Observable<ApiWorkflowTemplate>;
    public createWorkflowTemplateVersion(body: ApiWorkflowTemplate, namespace: string, workflowTemplateUid: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ApiWorkflowTemplate>>;
    public createWorkflowTemplateVersion(body: ApiWorkflowTemplate, namespace: string, workflowTemplateUid: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ApiWorkflowTemplate>>;
    public createWorkflowTemplateVersion(body: ApiWorkflowTemplate, namespace: string, workflowTemplateUid: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createWorkflowTemplateVersion.');
        }

        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling createWorkflowTemplateVersion.');
        }

        if (workflowTemplateUid === null || workflowTemplateUid === undefined) {
            throw new Error('Required parameter workflowTemplateUid was null or undefined when calling createWorkflowTemplateVersion.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<ApiWorkflowTemplate>('post',`${this.basePath}/apis/v1beta1/${encodeURIComponent(String(namespace))}/workflow_templates/${encodeURIComponent(String(workflowTemplateUid))}/versions`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param namespace 
     * @param name 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getWorkflow(namespace: string, name: string, observe?: 'body', reportProgress?: boolean): Observable<ApiWorkflow>;
    public getWorkflow(namespace: string, name: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ApiWorkflow>>;
    public getWorkflow(namespace: string, name: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ApiWorkflow>>;
    public getWorkflow(namespace: string, name: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling getWorkflow.');
        }

        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling getWorkflow.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<ApiWorkflow>('get',`${this.basePath}/apis/v1beta1/${encodeURIComponent(String(namespace))}/workflows/${encodeURIComponent(String(name))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param namespace 
     * @param name 
     * @param podName 
     * @param containerName 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getWorkflowLogs(namespace: string, name: string, podName: string, containerName: string, observe?: 'body', reportProgress?: boolean): Observable<XStreamDefinitionsapiLogEntry>;
    public getWorkflowLogs(namespace: string, name: string, podName: string, containerName: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<XStreamDefinitionsapiLogEntry>>;
    public getWorkflowLogs(namespace: string, name: string, podName: string, containerName: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<XStreamDefinitionsapiLogEntry>>;
    public getWorkflowLogs(namespace: string, name: string, podName: string, containerName: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling getWorkflowLogs.');
        }

        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling getWorkflowLogs.');
        }

        if (podName === null || podName === undefined) {
            throw new Error('Required parameter podName was null or undefined when calling getWorkflowLogs.');
        }

        if (containerName === null || containerName === undefined) {
            throw new Error('Required parameter containerName was null or undefined when calling getWorkflowLogs.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<XStreamDefinitionsapiLogEntry>('get',`${this.basePath}/apis/v1beta1/${encodeURIComponent(String(namespace))}/workflows/${encodeURIComponent(String(name))}/pods/${encodeURIComponent(String(podName))}/containers/${encodeURIComponent(String(containerName))}/logs`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param namespace 
     * @param name 
     * @param podName 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getWorkflowMetrics(namespace: string, name: string, podName: string, observe?: 'body', reportProgress?: boolean): Observable<ApiGetWorkflowMetricsResponse>;
    public getWorkflowMetrics(namespace: string, name: string, podName: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ApiGetWorkflowMetricsResponse>>;
    public getWorkflowMetrics(namespace: string, name: string, podName: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ApiGetWorkflowMetricsResponse>>;
    public getWorkflowMetrics(namespace: string, name: string, podName: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling getWorkflowMetrics.');
        }

        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling getWorkflowMetrics.');
        }

        if (podName === null || podName === undefined) {
            throw new Error('Required parameter podName was null or undefined when calling getWorkflowMetrics.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<ApiGetWorkflowMetricsResponse>('get',`${this.basePath}/apis/v1beta1/${encodeURIComponent(String(namespace))}/workflows/${encodeURIComponent(String(name))}/pods/${encodeURIComponent(String(podName))}/metrics`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param namespace 
     * @param uid 
     * @param version 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getWorkflowTemplate(namespace: string, uid: string, version?: number, observe?: 'body', reportProgress?: boolean): Observable<ApiWorkflowTemplate>;
    public getWorkflowTemplate(namespace: string, uid: string, version?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ApiWorkflowTemplate>>;
    public getWorkflowTemplate(namespace: string, uid: string, version?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ApiWorkflowTemplate>>;
    public getWorkflowTemplate(namespace: string, uid: string, version?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling getWorkflowTemplate.');
        }

        if (uid === null || uid === undefined) {
            throw new Error('Required parameter uid was null or undefined when calling getWorkflowTemplate.');
        }


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (version !== undefined && version !== null) {
            queryParameters = queryParameters.set('version', <any>version);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<ApiWorkflowTemplate>('get',`${this.basePath}/apis/v1beta1/${encodeURIComponent(String(namespace))}/workflow_templates/${encodeURIComponent(String(uid))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param namespace 
     * @param uid 
     * @param version 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getWorkflowTemplate2(namespace: string, uid: string, version: number, observe?: 'body', reportProgress?: boolean): Observable<ApiWorkflowTemplate>;
    public getWorkflowTemplate2(namespace: string, uid: string, version: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ApiWorkflowTemplate>>;
    public getWorkflowTemplate2(namespace: string, uid: string, version: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ApiWorkflowTemplate>>;
    public getWorkflowTemplate2(namespace: string, uid: string, version: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling getWorkflowTemplate2.');
        }

        if (uid === null || uid === undefined) {
            throw new Error('Required parameter uid was null or undefined when calling getWorkflowTemplate2.');
        }

        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling getWorkflowTemplate2.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<ApiWorkflowTemplate>('get',`${this.basePath}/apis/v1beta1/${encodeURIComponent(String(namespace))}/workflow_templates/${encodeURIComponent(String(uid))}/versions/${encodeURIComponent(String(version))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param namespace 
     * @param uid 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public listWorkflowTemplateVersions(namespace: string, uid: string, observe?: 'body', reportProgress?: boolean): Observable<ApiListWorkflowTemplateVersionsResponse>;
    public listWorkflowTemplateVersions(namespace: string, uid: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ApiListWorkflowTemplateVersionsResponse>>;
    public listWorkflowTemplateVersions(namespace: string, uid: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ApiListWorkflowTemplateVersionsResponse>>;
    public listWorkflowTemplateVersions(namespace: string, uid: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling listWorkflowTemplateVersions.');
        }

        if (uid === null || uid === undefined) {
            throw new Error('Required parameter uid was null or undefined when calling listWorkflowTemplateVersions.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<ApiListWorkflowTemplateVersionsResponse>('get',`${this.basePath}/apis/v1beta1/${encodeURIComponent(String(namespace))}/workflow_templates/${encodeURIComponent(String(uid))}/versions`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param namespace 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public listWorkflowTemplates(namespace: string, observe?: 'body', reportProgress?: boolean): Observable<ApiListWorkflowTemplatesResponse>;
    public listWorkflowTemplates(namespace: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ApiListWorkflowTemplatesResponse>>;
    public listWorkflowTemplates(namespace: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ApiListWorkflowTemplatesResponse>>;
    public listWorkflowTemplates(namespace: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling listWorkflowTemplates.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<ApiListWorkflowTemplatesResponse>('get',`${this.basePath}/apis/v1beta1/${encodeURIComponent(String(namespace))}/workflow_templates`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param namespace 
     * @param workflowTemplateUid 
     * @param workflowTemplateVersion 
     * @param pageSize 
     * @param page 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public listWorkflows(namespace: string, workflowTemplateUid?: string, workflowTemplateVersion?: string, pageSize?: number, page?: number, observe?: 'body', reportProgress?: boolean): Observable<ApiListWorkflowsResponse>;
    public listWorkflows(namespace: string, workflowTemplateUid?: string, workflowTemplateVersion?: string, pageSize?: number, page?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ApiListWorkflowsResponse>>;
    public listWorkflows(namespace: string, workflowTemplateUid?: string, workflowTemplateVersion?: string, pageSize?: number, page?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ApiListWorkflowsResponse>>;
    public listWorkflows(namespace: string, workflowTemplateUid?: string, workflowTemplateVersion?: string, pageSize?: number, page?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling listWorkflows.');
        }





        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (workflowTemplateUid !== undefined && workflowTemplateUid !== null) {
            queryParameters = queryParameters.set('workflowTemplateUid', <any>workflowTemplateUid);
        }
        if (workflowTemplateVersion !== undefined && workflowTemplateVersion !== null) {
            queryParameters = queryParameters.set('workflowTemplateVersion', <any>workflowTemplateVersion);
        }
        if (pageSize !== undefined && pageSize !== null) {
            queryParameters = queryParameters.set('pageSize', <any>pageSize);
        }
        if (page !== undefined && page !== null) {
            queryParameters = queryParameters.set('page', <any>page);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<ApiListWorkflowsResponse>('get',`${this.basePath}/apis/v1beta1/${encodeURIComponent(String(namespace))}/workflows`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param namespace 
     * @param name 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public resubmitWorkflow(namespace: string, name: string, observe?: 'body', reportProgress?: boolean): Observable<ApiWorkflow>;
    public resubmitWorkflow(namespace: string, name: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ApiWorkflow>>;
    public resubmitWorkflow(namespace: string, name: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ApiWorkflow>>;
    public resubmitWorkflow(namespace: string, name: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling resubmitWorkflow.');
        }

        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling resubmitWorkflow.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<ApiWorkflow>('put',`${this.basePath}/apis/v1beta1/${encodeURIComponent(String(namespace))}/workflows/${encodeURIComponent(String(name))}/resubmit`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param namespace 
     * @param name 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public terminateWorkflow(namespace: string, name: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public terminateWorkflow(namespace: string, name: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public terminateWorkflow(namespace: string, name: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public terminateWorkflow(namespace: string, name: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling terminateWorkflow.');
        }

        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling terminateWorkflow.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<any>('put',`${this.basePath}/apis/v1beta1/${encodeURIComponent(String(namespace))}/workflows/${encodeURIComponent(String(name))}/terminate`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param body 
     * @param namespace 
     * @param workflowTemplateUid 
     * @param workflowTemplateVersion 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updateWorkflowTemplateVersion(body: ApiWorkflowTemplate, namespace: string, workflowTemplateUid: string, workflowTemplateVersion: number, observe?: 'body', reportProgress?: boolean): Observable<ApiWorkflowTemplate>;
    public updateWorkflowTemplateVersion(body: ApiWorkflowTemplate, namespace: string, workflowTemplateUid: string, workflowTemplateVersion: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ApiWorkflowTemplate>>;
    public updateWorkflowTemplateVersion(body: ApiWorkflowTemplate, namespace: string, workflowTemplateUid: string, workflowTemplateVersion: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ApiWorkflowTemplate>>;
    public updateWorkflowTemplateVersion(body: ApiWorkflowTemplate, namespace: string, workflowTemplateUid: string, workflowTemplateVersion: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling updateWorkflowTemplateVersion.');
        }

        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling updateWorkflowTemplateVersion.');
        }

        if (workflowTemplateUid === null || workflowTemplateUid === undefined) {
            throw new Error('Required parameter workflowTemplateUid was null or undefined when calling updateWorkflowTemplateVersion.');
        }

        if (workflowTemplateVersion === null || workflowTemplateVersion === undefined) {
            throw new Error('Required parameter workflowTemplateVersion was null or undefined when calling updateWorkflowTemplateVersion.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<ApiWorkflowTemplate>('put',`${this.basePath}/apis/v1beta1/${encodeURIComponent(String(namespace))}/workflow_templates/${encodeURIComponent(String(workflowTemplateUid))}/versions/${encodeURIComponent(String(workflowTemplateVersion))}`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param namespace 
     * @param name 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public watchWorkflow(namespace: string, name: string, observe?: 'body', reportProgress?: boolean): Observable<XStreamDefinitionsapiWorkflow>;
    public watchWorkflow(namespace: string, name: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<XStreamDefinitionsapiWorkflow>>;
    public watchWorkflow(namespace: string, name: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<XStreamDefinitionsapiWorkflow>>;
    public watchWorkflow(namespace: string, name: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling watchWorkflow.');
        }

        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling watchWorkflow.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<XStreamDefinitionsapiWorkflow>('get',`${this.basePath}/apis/v1beta1/${encodeURIComponent(String(namespace))}/workflows/${encodeURIComponent(String(name))}/watch`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
